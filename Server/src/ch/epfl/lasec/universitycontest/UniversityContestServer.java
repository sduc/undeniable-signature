package ch.epfl.lasec.universitycontest;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

import ch.epfl.lasec.IOHelper;
import ch.epfl.lasec.mova.KeyPair;
import ch.epfl.lasec.mova.KeyPairGenerator;
import ch.epfl.lasec.mova.Mova;


/**
 * 
 * Class used for the server of the application university contest.
 * 
 * @author Sebastien Duc
 *
 */
public class UniversityContestServer {

	/**
	 * Server socket
	 */
	private ServerSocket serverSocket;
	
	private final static String MOVAKEYS_FILE = "mkeys";
	private final static String MOVA_INSTANCE_FILE = "mova";
	
	
	/**
	 * Server port to use for the simulator
	 */
	public final static int SERVER_PORT = 12345;
	
	/**
	 * Keys used by to sign.
	 * They are generated by the server.
	 */
	private KeyPair movaKeys;
	
	/**
	 * Mova instance used for signatures.
	 */
	private Mova movaInstance;
	
	
	/**
	 * Creates a server, and a socket that will listen port SERVER_PORT
	 * @throws IOException
	 */
	public UniversityContestServer() throws IOException {
		serverSocket = new ServerSocket(SERVER_PORT);

		File movaFile = new File(MOVA_INSTANCE_FILE);
		File movaKeysFile = new File(MOVAKEYS_FILE);

		if (!movaFile.exists() || !movaKeysFile.exists()) {

			movaKeys = new KeyPairGenerator(20, 1024, 64 / 8).generateKeyPair();
			System.out.println("Key pair generated : " + movaKeys.getPk());

			movaInstance = Mova.createMovaInstance(movaKeys.getPk(), 20, 5, 5);
			System.out.println("Mova instance created : " + movaInstance);

			FileOutputStream fos1 = new FileOutputStream(movaFile);
			FileOutputStream fos2 = new FileOutputStream(movaKeysFile);

			movaInstance.write(fos1);
			movaKeys.write(fos2);
			
			IOHelper.closeQuietly(fos1);
			IOHelper.closeQuietly(fos2);

		} else {
			System.out.println("Load security parameters...");
			FileInputStream fis1 = new FileInputStream(movaFile);
			FileInputStream fis2 = new FileInputStream(movaKeysFile);

			this.movaInstance = Mova.read(fis1);
			this.movaKeys = KeyPair.read(fis2);
			
			IOHelper.closeQuietly(fis1);
			IOHelper.closeQuietly(fis2);
			System.out.println("Security paramters loaded");
		}
	}
	
	/**
	 * Start server. Server start listening port and create a new thread for each client.
	 */
	public void startServer(){
		do {
			try {
				
				Socket clientSocket = serverSocket.accept();
				ClientServiceThread clientTread = 
						new ClientServiceThread(clientSocket,movaInstance,movaKeys);
				clientTread.start();
					
			} catch (IOException e) {
				System.out.println("Server listening: error on accept");
				e.printStackTrace();
			}
		} while (true);
	}
	
}


/**
 * Class used to handle on client.
 * 
 * @author Sebastien Duc
 *
 */
class ClientServiceThread extends Thread {
	
	private Socket socket;
	private Mova movaInstance;
	private KeyPair movaKeys;
	private int teamID;
	
	private InputStream in = null;
	private OutputStream out = null;
	
	public ClientServiceThread(Socket s,Mova mova,KeyPair keyPair) {
		this.socket = s;
		this.movaInstance = mova;
		this.movaKeys = keyPair;
	}
	
	@Override
	public void run() {
		
		
		System.out.println("New client connected");
		
		try {
			
			in = socket.getInputStream();
			out = socket.getOutputStream();
			
			boolean valid = authentication();
			
			if (valid) {
				ServerContext sContext = new ServerContext(this);
				sContext.getCurrentState().handle(sContext);
			}
			
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			
			System.out.println("Client leaving");
			// close everything
			IOHelper.closeQuietly(in);
			IOHelper.closeQuietly(out);
			
			try {
				socket.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

	public Socket getSocket() {
		return socket;
	}

	public Mova getMovaInstance() {
		return movaInstance;
	}

	public KeyPair getMovaKeys() {
		return movaKeys;
	}

	public InputStream getIn() {
		return in;
	}

	public OutputStream getOut() {
		return out;
	}

	public int getTeamID() {
		return teamID;
	}
	
	private boolean authentication() throws IOException{
		int q = in.read();
		if (q != UniversityContestProtocol.AUTH)
			return false;
		
		this.teamID = IOHelper.readEncodedBigInt(in).intValue();
		
		boolean c = checkTeamID();
		
		if(c){
			out.write(0);
			ChallengeResponse cr = new ChallengeResponse(teamID);
			c = cr.challenge(getSecret(), in, out);
		}
		else {
			out.write(UniversityContestProtocol.END);
			return false;
		}
			
		UniversityContestProtocol.handleTeamAuthentication(in, out, c);
		return c;
	}
	
	/**
	 * Check the validity of the teamID
	 * @return true if it is valid false otherwise.
	 */
	private boolean checkTeamID(){
		DataBaseHandler dbh = new DataBaseHandler();
		boolean ret = false;
		try {
			dbh.connect();
			ret = dbh.checkTeamID(teamID);
			dbh.disconnect();
		} catch (NotConnectDBException e) {
			ret = false;
		} finally {
			
		}
		return ret;
	}
	
	private String getSecret(){
		DataBaseHandler dbh = new DataBaseHandler();
		String s = null;
		try {
			dbh.connect();
			s = dbh.getSecret(teamID);
			dbh.disconnect();
		} catch (NotConnectDBException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return s;
	}
	
}

/**
 * Context of the server. It keeps track of the state of the protocol.
 * 
 * @author Sebastien Duc
 *
 */
class ServerContext {
	
	private ServerProtocolState currentState = null;
	private ClientServiceThread clientService = null;

	public ServerContext(ClientServiceThread c) {
		this.clientService = c;
		currentState = new InitState();
	}

	public ServerProtocolState getCurrentState() {
		return currentState;
	}

	public void setCurrentState(ServerProtocolState currentState) {
		this.currentState = currentState;
	}

	public ClientServiceThread getClientService() {
		return clientService;
	}
	
}
